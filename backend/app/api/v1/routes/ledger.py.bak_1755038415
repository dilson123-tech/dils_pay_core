# app/api/v1/routes/ledger.py
from __future__ import annotations

from fastapi import APIRouter, Depends, Query, Response
from sqlalchemy.orm import Session
from sqlalchemy import func, case, asc, desc
from typing import Literal, Optional, Tuple, Any

from app.database.session import get_db

# --- resolve o model (Transaction ou TransactionModel) ---
try:
    from app.models.transaction import Transaction as TransactionModel  # type: ignore
except Exception:
    from app.models.transaction import TransactionModel as TransactionModel  # type: ignore

router = APIRouter()

TipoMov = Literal["CREDITO", "DEBITO"]

# ----------------- Helpers dinâmicos de coluna -----------------
def _col(model: Any, candidates: list[str]) -> Tuple[Any, str]:
    """
    Retorna (coluna_sqlalchemy, nome_str) do primeiro atributo existente no model.
    Lança erro legível se não encontrar.
    """
    for name in candidates:
        if hasattr(model, name):
            return getattr(model, name), name
    raise RuntimeError(f"Não achei nenhuma das colunas {candidates} em {model.__name__}")

# Mapeia nomes comuns -> pega o que existir no seu schema
ID_COL, ID_NAME             = _col(TransactionModel, ["id", "transaction_id", "movimento_id"])
LEDGER_COL, LEDGER_NAME     = _col(TransactionModel, ["ledger_id", "wallet_id", "carteira_id", "account_id", "conta_id"])
DATA_COL, DATA_NAME         = _col(TransactionModel, ["data", "created_at", "timestamp", "dt", "data_hora"])
TIPO_COL, TIPO_NAME         = _col(TransactionModel, ["tipo", "movement_type", "direction", "kind", "tipo_mov"])
VALOR_COL, VALOR_NAME       = _col(TransactionModel, ["valor", "amount", "value", "valor_centavos"])
DESC_COL, DESC_NAME         = _col(TransactionModel, ["descricao", "description", "memo", "observacao", "details"])

# Campos permitidos para ordenação (chaves públicas -> colunas reais)
ORDER_MAP = {
    "id": ID_COL,
    "data": DATA_COL,
    "tipo": TIPO_COL,
    "valor": VALOR_COL,
    "descricao": DESC_COL,
}
VALID_ORDER_FIELDS = set(ORDER_MAP.keys())

def _iso_or_none(s: Optional[str]) -> Optional[str]:
    if not s: 
        return None
    s = s.strip()
    return s or None

@router.get("/ledger/{ledger_id}")
def get_ledger(
    ledger_id: int,
    response: Response,
    page: int = Query(1, ge=1),
    page_size: int = Query(10, ge=1, le=200),
    tipo: Optional[TipoMov] = Query(default=None),   # aceita CREDITO/DEBITO
    start: Optional[str] = None,   # ISO ex: 2025-08-12T00:00:00
    end: Optional[str] = None,     # ISO ex: 2025-08-12T23:59:59
    order_by: str = Query("data"),
    order_dir: Literal["asc", "desc"] = Query("desc"),
    db: Session = Depends(get_db),
):
    """
    Extrato paginado com totais globais nos headers.
    Headers: X-Total, X-Total-Credito, X-Total-Debito, X-Total-Saldo,
             X-Total-Pages, X-Page, X-Page-Size
    """
    # 1) Base + filtros
    q = db.query(TransactionModel).filter(LEDGER_COL == ledger_id)

    if tipo:
        # Se seu schema usa "credit"/"debit", adapte aqui (ex.: map {"CREDITO":"credit", ...})
        q = q.filter(TIPO_COL == tipo)

    s = _iso_or_none(start)
    e = _iso_or_none(end)
    if s:
        q = q.filter(DATA_COL >= s)
    if e:
        q = q.filter(DATA_COL <= e)

    # 2) Subquery enxuta para agregações
    subq = q.with_entities(ID_COL.label("id"),
                           DATA_COL.label("data"),
                           TIPO_COL.label("tipo"),
                           VALOR_COL.label("valor"),
                           DESC_COL.label("descricao")).subquery()

    total_count = db.query(func.count()).select_from(subq).scalar() or 0

    tot_credito, tot_debito = db.query(
        func.coalesce(func.sum(case((subq.c.tipo == "CREDITO", subq.c.valor), else_=0.0)), 0.0),
        func.coalesce(func.sum(case((subq.c.tipo == "DEBITO",  subq.c.valor), else_=0.0)), 0.0),
    ).one()

    tot_credito = float(tot_credito or 0.0)
    tot_debito  = float(tot_debito  or 0.0)
    saldo = tot_credito - tot_debito

    # 3) Ordenação server-side
    col = ORDER_MAP.get(order_by, ORDER_MAP["data"])
    q_sorted = q.order_by(asc(col) if order_dir == "asc" else desc(col))

    # 4) Paginação
    items = q_sorted.offset((page - 1) * page_size).limit(page_size).all()

    # 5) Headers globais
    total_pages = max(1, (total_count + page_size - 1) // page_size)
    response.headers["X-Total"] = str(total_count)
    response.headers["X-Total-Count"] = str(total_count)
    response.headers["X-Total-Pages"] = str(total_pages)
    response.headers["X-Page"] = str(page)
    response.headers["X-Page-Size"] = str(page_size)
    response.headers["X-Total-Credito"] = f"{tot_credito:.2f}"
    response.headers["X-Total-Debito"]  = f"{tot_debito:.2f}"
    response.headers["X-Total-Saldo"]   = f"{saldo:.2f}"

    # 6) Serialização (usa nomes públicos padronizados)
    out = []
    for it in items:
        data_val = getattr(it, DATA_NAME, None)
        if hasattr(data_val, "isoformat"):
            data_iso = data_val.isoformat()
        else:
            data_iso = str(data_val) if data_val is not None else ""

        out.append({
            "id": getattr(it, ID_NAME, None),
            "data": data_iso,
            "tipo": getattr(it, TIPO_NAME, None),
            "valor": float(getattr(it, VALOR_NAME, 0.0) or 0.0),
            "descricao": getattr(it, DESC_NAME, "") or "",
        })
    return out
