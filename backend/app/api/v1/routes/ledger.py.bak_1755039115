# app/api/v1/routes/ledger.py
from __future__ import annotations

from fastapi import APIRouter, Depends, Query, Response, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import func, case, asc, desc
from typing import Literal, Optional

from app.database.session import get_db

# Tenta importar o model com nomes comuns
try:
    from app.models.transaction import Transaction as TM  # type: ignore
except Exception:
    from app.models.transaction import TransactionModel as TM  # type: ignore

router = APIRouter()
TipoMov = Literal["CREDITO", "DEBITO"]

def pick_col(model, prefer:list[str], contains:list[str]|None=None):
    """Escolhe uma coluna do model. 1) nome exato; 2) por heurística de substring."""
    cols = {c.name: c for c in model.__table__.columns}  # type: ignore[attr-defined]
    # match exato
    for n in prefer:
        if n in cols:
            return getattr(model, n), n
    # heurística por substring
    if contains:
        for name, col in cols.items():
            low = name.lower()
            if any(tok in low for tok in contains):
                return getattr(model, name), name
    # não achou
    return None, None

@router.get("/ledger/{ledger_id}")
def get_ledger(
    ledger_id: int,
    response: Response,
    page: int = Query(1, ge=1),
    page_size: int = Query(10, ge=1, le=200),
    tipo: Optional[TipoMov] = Query(default=None),
    start: Optional[str] = None,   # ISO ex: 2025-08-12T00:00:00
    end: Optional[str] = None,     # ISO ex: 2025-08-12T23:59:59
    order_by: str = Query("data"),
    order_dir: Literal["asc", "desc"] = Query("desc"),
    db: Session = Depends(get_db),
):
    # ----- resolve colunas dinamicamente (NADA em import-time) -----
    ID_COL,  ID_NAME  = pick_col(TM, ["id", "transaction_id", "movimento_id"], ["id"])
    LEDGER_COL, LEDGER_NAME = pick_col(TM, ["ledger_id", "wallet_id", "carteira_id", "account_id", "conta_id"], ["ledger", "wallet", "carte", "account", "conta"])
    DATA_COL, DATA_NAME = pick_col(TM, ["data", "created_at", "timestamp", "dt", "data_hora", "datahora"], ["data", "date", "time"])
    TIPO_COL, TIPO_NAME = pick_col(TM, ["tipo", "movement_type", "direction", "kind", "tipo_mov"], ["tipo", "type", "cred", "deb"])
    VALOR_COL, VALOR_NAME = pick_col(TM, ["valor", "amount", "value", "valor_centavos"], ["valor", "amount", "value"])
    DESC_COL,  DESC_NAME  = pick_col(TM, ["descricao", "description", "memo", "observacao", "details"], ["desc", "observ", "memo", "detail"])

    missing = [n for (c, n) in [(ID_COL, "id"), (LEDGER_COL, "ledger_id/wallet_id"), (DATA_COL, "data/created_at"), (TIPO_COL, "tipo"), (VALOR_COL, "valor")] if c is None]
    if missing:
        raise HTTPException(status_code=500, detail=f"Columns not found in Transaction: {', '.join(missing)}. Disponíveis: {list(TM.__table__.columns.keys())}")  # type: ignore

    # ----- query base + filtros -----
    q = db.query(TM).filter(LEDGER_COL == ledger_id)

    if tipo:
        q = q.filter(TIPO_COL == tipo)

    if start:
        q = q.filter(DATA_COL >= start.strip())
    if end:
        q = q.filter(DATA_COL <= end.strip())

    # ----- agregações globais (ignoram paginação) -----
    subq = q.with_entities(
        ID_COL.label("id"),
        DATA_COL.label("data"),
        TIPO_COL.label("tipo"),
        VALOR_COL.label("valor"),
        DESC_COL.label("descricao") if DESC_COL is not None else VALOR_COL.label("valor"),  # só pra ter 5 colunas no subq
    ).subquery()

    total_count = db.query(func.count()).select_from(subq).scalar() or 0

    tot_credito, tot_debito = db.query(
        func.coalesce(func.sum(case((subq.c.tipo == "CREDITO", subq.c.valor), else_=0.0)), 0.0),
        func.coalesce(func.sum(case((subq.c.tipo == "DEBITO",  subq.c.valor), else_=0.0)), 0.0),
    ).one()

    tot_credito = float(tot_credito or 0.0)
    tot_debito  = float(tot_debito  or 0.0)
    saldo = tot_credito - tot_debito

    # ----- ordenação server-side -----
    ORDER_MAP = {
        "id": ID_COL, "data": DATA_COL, "tipo": TIPO_COL, "valor": VALOR_COL, "descricao": (DESC_COL or ID_COL)
    }
    order_col = ORDER_MAP.get(order_by, DATA_COL)
    q_sorted = q.order_by(asc(order_col) if order_dir == "asc" else desc(order_col))

    # ----- paginação -----
    items = q_sorted.offset((page - 1) * page_size).limit(page_size).all()

    # ----- headers -----
    total_pages = max(1, (total_count + page_size - 1) // page_size)
    response.headers["X-Total"] = str(total_count)
    response.headers["X-Total-Count"] = str(total_count)
    response.headers["X-Total-Pages"] = str(total_pages)
    response.headers["X-Page"] = str(page)
    response.headers["X-Page-Size"] = str(page_size)
    response.headers["X-Total-Credito"] = f"{tot_credito:.2f}"
    response.headers["X-Total-Debito"]  = f"{tot_debito:.2f}"
    response.headers["X-Total-Saldo"]   = f"{saldo:.2f}"

    # ----- corpo -----
    out = []
    for it in items:
        data_val = getattr(it, DATA_NAME, None)
        data_iso = data_val.isoformat() if hasattr(data_val, "isoformat") else (str(data_val) if data_val is not None else "")
        out.append({
            "id": getattr(it, ID_NAME, None),
            "data": data_iso,
            "tipo": getattr(it, TIPO_NAME, None),
            "valor": float(getattr(it, VALOR_NAME, 0.0) or 0.0),
            "descricao": (getattr(it, DESC_NAME, "") if DESC_COL is not None else "") or "",
        })
    return out
